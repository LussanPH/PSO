import random as rd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn import metrics
import pandas
class Particula:
    def __init__(self, v, pA):
        self.v = v
        self.pA = pA
        self.mL = None
        self.Vn = None
        self.c1 = rd.uniform(0, 3)
        self.c2 = rd.uniform(0, 3)
        self.pN = None        

    def melhorLocal(self):
        if(self.mL != None):
            if(pso.avaliacao(self.pA) > pso.avaliacao(self.mL)):
                self.mL = self.pA   
            self.mLAccuracy = pso.avaliacao(self.mL)    
            return self.mL     
        else:
            self.mL = self.pA 
            self.mLAccuracy = pso.avaliacao(self.mL)   
            return self.mL           

    def atualizarVelocidade(self, mG):
        self.Vn = self.v + self.c1*(self.mL - self.pA) + self.c2*(mG - self.pA)

    def posicaoNova(self):
        self.pN = self.Vn + self.pA       

    def __str__(self):
        return f"posicao atual: {self.pA} melhor local: {self.mL}"        
    
class PSO:
    def __init__(self, num, enx, model, dados):
        self.num = num
        self.enx = enx
        self.model = model
        self.dados = pandas.read_csv(dados)

    def gerarPosicoesAleatorias(self):
        self.listaP = []
        i = 0
        if(self.model == 0):
            while(i != self.num):
                pos = [rd.randint(3, 150), rd.randint(0,2), rd.uniform(0.01, 0.9)]
                self.listaP.append(pos)
                self.Pinicial = [76, 1, 0.55]
                i+=1
        return self.listaP

    def calcularVIniciais(self):
        self.listaV = []
        self.listaP = np.array(self.listaP)
        np.set_printoptions(formatter={'float' : "{: 0.2f}".format})
        print(self.listaP)
        for item in self.listaP:
            sub = item - self.Pinicial                
            self.listaV.append(sub)
        print(self.listaV)

    def gerarXy(self):
        self.X = self.dados.iloc[:, :-1].values #pega todas as colunas menos o target
        self.y = self.dados.iloc[:, -1].values  #pega apenas a coluna do target
        self.X_treino, self.X_teste, self.y_treino, self.y_teste = train_test_split(self.X, self.y, test_size=0.3, random_state=1) 

    def avaliacao(self, posicao):
        self.gerarXy()
        if(self.model == 0):
            tradutor = {0.00:"gini", 1.00:"entropy", 2.00:"log_loss"}
            arvore = DecisionTreeClassifier(max_depth=int(posicao[0]), criterion=tradutor[posicao[1]], min_samples_split=posicao[2])
            arvore.fit(self.X_treino, self.y_treino)
            previsao = arvore.predict(self.X_teste)
            acuracia = metrics.accuracy_score(self.y_teste, previsao)
            return acuracia
    
    def gerarParticula(self, v, pA):
        self.p = Particula(v, pA)
        return self.p
    
    def gerarGlobal(self, mL):
        maior = 0
        lista = []
        i = 0
        melhor = 0
        self.acuracia = 0
        for ml in mL:
            lista.append(self.avaliacao(ml))
        for item in lista:
            if(item > maior):
                maior = item
                melhor = i
            i+=1
        self.acuracia = lista[melhor]        
        return mL[melhor]        
    
    def gerarEnxame(self):  
        listaE = []
        listaML = []
        i = 0
        while(i != self.num):
            listaE.append(self.gerarParticula(self.listaV[i], self.listaP[i]))
            listaML.append(listaE[i].melhorLocal())
            i+=1
        i = 0    
        mG = self.gerarGlobal(listaML)
        for particula in listaE:
            particula.atualizarVelocidade(mG)
            particula.posicaoNova()
            print(particula," com acuracia: ",particula.mLAccuracy)
        print("melhor global: ", mG, " com acuracia: ", self.acuracia)
           


pso = PSO(10, 10, 0, "diabetes (1).csv")
print(pso.gerarPosicoesAleatorias())
print("------------------------------\n---------------------------")
pso.calcularVIniciais()
pso.gerarEnxame()
